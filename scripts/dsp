#!/usr/bin/env bash

# DS - Daily Shells Library
# License:
#   See README.md document in projects page at
#   https://github.com/stroparo/ds

# ##############################################################################
# Globals

export PNAME="$(basename "$0")"
export USAGE="
NAME
    ${PNAME} - parallel process launcher

SYNOPSIS
    ${PNAME} [-q] [-t] [-l {logdir}] ...
    ... [-n {args-per-process}] [-p {maxprocesses}] [-z {taskname}]
    ... {command}

DESCRIPTION
    Call processes in background, producing concurrency effect (or parallelism when
    in a multi-core CPU environment). Each run corresponds to a line of stdin.
    In the command, each instance of the {} character sequence is replaced by
    the corresponding entry and quoted.

OPTIONS
    -l {logdir}
        Defaults to $DS_ENV_LOG
    -q
        Quiet. Do not display informational messages.
    -t
        Tee. Echoes each process log to stdout after all processes have finished.

    -z {CMDZERO, generic taskname to use in the log filename etc.}

        Specify the task name for example when the command starts
        with other stuff in lieu of the command, such as IFS=...
        This is what gets put into the log filename.

EXAMPLES
    gzip {}

"

export HALTSTRING='__HALT__'
export LOGSUFFIXMULTI='psno_'
export TIMESTAMP="$(date '+%Y%m%d%OH%OM%OS')"

# ##############################################################################
# Prep args

# Options:

export DOTEE=false
export LOGDIR="${DS_ENV_LOG}"
export MAXPROCS=4
export N=1
export QUIET=false
export SUBSHELL=bash

while getopts ':hl:n:p:qs:tz:' opt ; do
    case "${opt}" in
    h) echo "$USAGE" ; exit ;;
    l) export LOGDIR="${OPTARG}";;
    n) export N="${OPTARG}";;
    p) export MAXPROCS="${OPTARG}";;
    q) export QUIET=true;;
    s) export SUBSHELL="${OPTARG}";;
    t) export DOTEE=true;;
    z) export CMDZERO="${OPTARG}";;
    esac
done
shift $((OPTIND - 1))

# ##############################################################################
# Prep

# Prep commands HERE...

# ##############################################################################
# Functions

prep () {

    if ! . "${DS_HOME}/ds.sh" "${DS_HOME}" >/dev/null 2>&1 || \
        [ -z "${DS_LOADED}" ]
    then
        echo "${PNAME}: FATAL: Could not load DS - Daily Shells." 1>&2
        exit 1
    fi

}

dsp () {

    typeset argcount=0
    typeset cmd flatentry iargs icmd ilog ilogsuffix
    typeset pcount=0

    cmd="${1} ; res=\$? ; echo \$(date '+%Y%m%d-%OH%OM%OS') ; echo \${res}"
    : ${CMDZERO:=${1%% *}}
    setlogdir "${LOGDIR}" || return 10

    # Enforce number type: 
    [[ ${MAXPROCS} = [1-9]* ]] || MAXPROCS=4
    [[ ${N} = [1-9]* ]] || N=1

    # Argcount fixed for N==1:
    [ "${N}" -eq 1 ] && argcount=1

    LOGS=()

    while read entry ; do
        [ -z "${entry}" ] && continue

        # Argument list:
        if [ "${N}" -eq 1 ] ; then
            flatentry="$(echo "${entry}" | sed -e 's#/#_#g')"
            ilogsuffix="${flatentry}"
            iargs="'${entry}'"
        elif [ "${N}" -gt 1 ] ; then
            [ "${argcount}" -eq "${N}" ] && argcount=0

            if [ "${entry}" != "${HALTSTRING}" ] ; then
                argcount=$((argcount+1))

                if [ "${argcount}" -eq 1 ] ; then
                    iargs="'${entry}'"
                else
                    iargs="${iargs} '${entry}'"
                fi

                [ "${argcount}" -lt "${N}" ] && continue
            fi
        else
            $QUIET || elog -f -n "${PNAME}" \
                "Invalid number of args per process in n option, must be positive."
            return 20
        fi

        # Halting control is best when processing multi-args at a time (n > 1):        
        if [ "${entry}" = "${HALTSTRING}" ] ; then
            if [ "${argcount:-0}" -eq 0 ] ; then
                $QUIET || elog -w "Halt string found but no arguments pending,"
                $QUIET || elog -w " ie either the input was empty or the number"
                $QUIET || elog -w " of entries was a multiple of n.."
                break
            fi

            $QUIET || elog -w "Halt string found; calling last job of this set.."
        fi

        # Prep command and its log filename:
        iargs="$(echo "${iargs}" | sed 's#&#\\&#g')"
        icmd="$(echo "${cmd}" | sed -e "s#[{][}]#${iargs}#g")" || return 30
        pcount=$((pcount+1))
        if [ "${N}" -gt 1 ] ; then
            ilogsuffix="${LOGSUFFIXMULTI}${pcount}"
        fi
        ilog="${LOGDIR}/${CMDZERO}_${TIMESTAMP}_${ilogsuffix}.log"
        if $DOTEE ; then LOGS=(${LOGS[@]} "$ilog") ; fi

        echo "Command: ${icmd}" > "${ilog}" || return 40

        # Wait for a vacant pool slot:
        while [ `jobs -r | wc -l` -ge ${MAXPROCS} ] ; do true ; done

        nohup $SUBSHELL -c "${icmd}" >> "${ilog}" 2>&1 &
    done

    if ! $QUIET && [ "${pcount}" -gt 0 ] ; then
        elog "Finished launching a total of ${pcount} processes for this jobset."
        elog "Processing last batch of `jobs -p | wc -l` jobs.."
    fi

    wait || return 1

    if $DOTEE ; then
        for log in ${LOGS[@]} ; do
            echo "$(ex "$log" <<EOF
            :/{res}$/+1,$p
EOF
            )" | \
                head -n -2
        done
    fi
}

# ##############################################################################
# Main

prep
dsp "$@"
exit "$?"

